/**
 * \file DCL.C
 *
 * \note As written, these tests catch template declarations only if
 * instantiated.
 *
 * Copyright (c) 2007 Carnegie Mellon University.
 * All rights reserved.

 * Permission to use this software and its documentation for any purpose is
 * hereby granted, provided that the above copyright notice appear and that
 * both that copyright notice and this permission notice appear in supporting
 * documentation, and that the name of CMU not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.
 *
 * CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WSTRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL CMU BE
 * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, RISING OUT OF OR
 * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "rose.h"
#include "utilities.h"
#include <boost/regex.hpp>

/**
 * Const-qualify immutable objects
 *
 * \todo count assignments, if only one, report violation
 */
bool DCL00_C( const SgNode *node ) {
	const SgInitializedName *varName = isSgInitializedName(node);
	if (!varName)
		return false;

	/**
	 * Ignore variables generated by macros
	 */
	if (varName->get_name().getString().substr(0,2) == "__")
		return false;

	/**
	 * Ignore variables that are already const, are function pointers, or are
	 * declared inside of a struct, enum, or as an argument to a function
	 */
	Type varType(varName->get_type());
	if (varType.isConst()
	|| varType.dereference().isConst()
	|| varType.dereference().dereference().isConst()
	|| varType.isFunction()
	|| isSgClassType(varName->get_type())
	|| findParentNodeOfType(varName, V_SgEnumDeclaration).first
	|| findParentNodeOfType(varName, V_SgClassDeclaration).first)
		return false;

	/**
	 * DCL13-C is a subset of this rule, figure out which rule we are dealing
	 * with here
	 */
	std::string ruleStr;
	std::string errStr;
	if (findParentNodeOfType(varName, V_SgFunctionParameterList).first) {
		if (Type(varName->get_type()).isPointer()
		||  Type(varName->get_type()).isArray()) {
			ruleStr = "DCL13-C";
			errStr = "Declare function parameters that are pointers to values not changed by the function as const: ";
		} else {
			return false;
		}
	} else {
		ruleStr = "DCL00-C";
		errStr = "Const-qualify immutable objects: ";
	}

	/**
	 * Ignore global variables or variables declared as extern
	 */
	const SgScopeStatement *varScope = varName->get_scope();
	if (isSgGlobal(varScope)
	|| const_cast<SgInitializedName*>(varName)->get_storageModifier().isExtern())
		return false;

	FOREACH_SUBNODE(varScope, nodes, i, V_SgVarRefExp) {
		const SgVarRefExp *iVar = isSgVarRefExp(*i);
		assert(iVar);
		if (getRefDecl(iVar) != varName)
			continue;

		const SgNode *parent = iVar->get_parent();
		while(isSgCastExp(parent)) {
			parent = parent->get_parent();
		}
		assert(parent);

		/**
		 * If the variable is written to or it's address is taken, we can no
		 * longer be sure it should be const, if it's a struct and gets
		 * dereferenced, who knows what's getting written there :/
		 *
		 * \todo Is this address thing correct?
		 */
		if (varWrittenTo(iVar)
		||  isSgArrowExp(parent)
		||  findParentNodeOfType(iVar, V_SgAddressOfOp).first)
			return false;

		/**
		 * If the variable is a pointer or array, and we pass it to a function
		 * or as an argument to pointer arithmetic, or assign it's value
		 * somewhere, we can longer be sure it should be const
		 */
		if ((varType.isPointer() || varType.isArray())
		&& (findParentNodeOfType(iVar, V_SgFunctionCallExp).first
			|| isSgAddOp(parent)
			|| isSgSubtractOp(parent)
			|| isSgAssignOp(parent)
			|| isSgPntrArrRefExp(parent)
			|| isSgPointerDerefExp(parent)
			|| isSgAssignInitializer(parent)))
			return false;
	}

	const std::string msg =  errStr + varName->unparseToString();
	print_error(node, ruleStr.c_str(), msg.c_str(), true);
	return true;
}

/**
 * Do not reuse variable names in subscopes
 */
bool DCL01_C( const SgNode *node ) {
	const SgInitializedName *varInitName = isSgInitializedName(node);
	if (!varInitName)
		return false;
	const SgName varName = varInitName->get_name();
	const SgScopeStatement *varScope = varInitName->get_scope();
	assert(varScope);
	while(!isSgGlobal(varScope)) {
		varScope = varScope->get_scope();
		if(varScope->symbol_exists(varName)) {
			print_error(node, "DCL01-C", "Do not reuse variable names in subscopes", true);
			return true;
		}
	}

	return false;
}

std::string normalize_string(std::string str) {
	size_t found;

	while((found = str.find_first_of("1")) != std::string::npos)
		str[found] = 'l';
	while((found = str.find_first_of("0")) != std::string::npos)
		str[found] = 'O';
	while((found = str.find_first_of("2")) != std::string::npos)
		str[found] = 'Z';
	while((found = str.find_first_of("5")) != std::string::npos)
		str[found] = 'S';
	while((found = str.find_first_of("8")) != std::string::npos)
		str[found] = 'B';

	return str;
}

/**
 * Use visually distinct identifiers 
 */
bool DCL02_C( const SgNode *node ) {
	static std::map<const SgScopeStatement *, std::set<std::string> > scopeMap;
	static std::map<std::string, const SgInitializedName *> strVarMap;

	const SgScopeStatement *scope = isSgScopeStatement(node);
	if (!scope)
		return false;

	bool violation = false;

	if (isSgGlobal(scope)) {
		/** populate scopeMap */
		FOREACH_SUBNODE(scope, nodes, i, V_SgInitializedName) {
			const SgInitializedName *var = isSgInitializedName(*i);
			assert(var);
			if (isCompilerGeneratedNode(var)
			|| !isSgDeclarationStatement(var->get_parent())
			|| var->get_name().getString().empty()
			|| (var->get_name().getString().substr(0,2) == "__"))
				continue;

			/** Ignore function prototypes */
			const SgFunctionDeclaration * fnDecl = isSgFunctionDeclaration(findParentNodeOfType(var, V_SgFunctionDeclaration).first);
			if (fnDecl && !fnDecl->get_definition())
				continue;

			const SgScopeStatement *varScope = var->get_scope();
			std::string str (normalize_string(var->get_name().str()));
			if (scopeMap[varScope].find(str) != scopeMap[varScope].end()) {
				print_error(var, "DCL02-C", "Use visually distinct identifiers", true);
				violation = true;
			} else {
				scopeMap[varScope].insert(str);
				strVarMap[str] = var;
			}
		}
		return false;
	}

	std::set<std::string> ids;
	do {
		if (isCompilerGeneratedNode(scope))
			continue;
		for (std::set<std::string>::iterator i = scopeMap[scope].begin(); i != scopeMap[scope].end(); i++) {
			if (ids.find(*i) != ids.end()) {
				const std::string msg = "Use visually distinct identifiers: " + *i;
				print_error(strVarMap[*i], "DCL02-C", msg.c_str(), true);
				violation = true;
			} else {
				ids.insert(*i);
			}
		}
	} while (!isSgGlobal(scope) && (scope = scope->get_scope()));

	return violation;
}

/**
 * Do not declare more than one variable per declaration 
 */
bool DCL04_C( const SgNode *node ) {
	const SgVariableDeclaration *varDec = isSgVariableDeclaration(node);
	if (!varDec)
		return false;

	/**
	 * \note Due to a bug in ROSE this comparison will always be false
	 */
	if (varDec->get_variables().size() > 1) {
		print_error(node, "DCL04-C", "Do not declare more than one variable per declaration", true);
		return true;
	}

	return false;
}

/**
 * Use typedefs to improve code readability
 *
 * \note our algorithm is to count open parens/brackets... if there are more
 * than 2, we flag
 */
bool DCL05_C( const SgNode *node ) {
	const SgInitializedName *var = isSgInitializedName(node);
	if (!var)
		return false;

	/**
	 * Ignore function definitions
	 */
	const SgDeclarationStatement *varDecl = var->get_declaration();
	assert(varDecl);
	if (isSgFunctionDeclaration(varDecl) && isSgFunctionDeclaration(varDecl)->get_definition())
		return false;

	/**
	 * \bug ROSE is missing the const version of derefence()
	 */
	SgType *t = var->get_type();
	assert(t);

	const unsigned int threshold = 4;
	unsigned int count = 0;
	unsigned int modifiers = 0;
	do {
		/** count modifiers because they add clutter */
		if (t->get_modifiers())
			modifiers += t->get_modifiers()->get_nodes().size();
		t = t->stripType(SgType::STRIP_MODIFIER_TYPE);

		/** obviously, typedefs should break us out */
		if (t != t->stripType(SgType::STRIP_TYPEDEF_TYPE))
			break;
		/** Count functions as two points */
		if (isSgFunctionType(t))
			count++;
		/** Arrays will derefence twice, so let's only count them once */
		if (isSgArrayType(t))
			count--;
		/** count all other pointers as one point */
		count++;
	} while ((t != t->dereference()) && (t = t->dereference()));
	if (isSgPointerType(t) || isSgFunctionType(t) || isSgArrayType(t))
		count++;

	if (count + (modifiers / 2) >= threshold) {
		print_error(node, "DCL05-C", "Use typedefs to improve code readability", true);
		return true;
	}
	return false;
}

bool DCL(const SgNode *node) {
  bool violation = false;
  violation |= DCL00_C(node);
  violation |= DCL01_C(node);
  violation |= DCL02_C(node);
  violation |= DCL04_C(node);
  violation |= DCL05_C(node);
  return violation;
}
